# System Commands

System commands provide essential functionality for health checking and monitoring the daemon. These commands are designed for operational use and do not require audit logging due to their high-frequency nature.

## Overview

| Command | Description |
|---------|-------------|
| `system.ping` | Health check endpoint that verifies daemon responsiveness |
| `system.metrics` | Returns daemon health statistics and performance metrics |

---

## system.ping

Simple ping command that returns a pong response. Used for health checks and verifying the daemon is responsive.

### Parameters

| Name | Type | Required | Description |
|------|------|----------|-------------|
| — | — | — | This command accepts no parameters |

### Response Format

| Field | Type | Description |
|-------|------|-------------|
| `pong` | boolean | Always `true` on success |
| `timestamp` | integer | Unix timestamp (seconds since epoch) when the response was generated |
| `request_id` | string | UUID of the request for tracing purposes |

### Example Request

```json
{
  "command": "system.ping",
  "params": {}
}
```

### Example Response

```json
{
  "success": true,
  "data": {
    "pong": true,
    "timestamp": 1704067200,
    "request_id": "550e8400-e29b-41d4-a716-446655440000"
  }
}
```

### Error Cases

This command has no specific error cases. It always succeeds if the daemon is running and able to process requests.

### Use Cases

#### Load Balancer Health Checks

Configure your load balancer to periodically call `system.ping` to verify the daemon is responsive:

```bash
# Example: HAProxy health check configuration
backend lumo_daemon
    option httpchk
    http-check send meth POST uri /ping body '{"command":"system.ping","params":{}}'
    server daemon1 /var/run/lumo/daemon.sock check inter 5s
```

#### Monitoring System Integration

Use `system.ping` with monitoring tools like Nagios, Prometheus, or custom scripts:

```bash
# Simple health check script
response=$(echo '{"command":"system.ping","params":{}}' | nc -U /var/run/lumo/daemon.sock)
if echo "$response" | jq -e '.data.pong == true' > /dev/null; then
    echo "OK: Daemon is responsive"
    exit 0
else
    echo "CRITICAL: Daemon not responding"
    exit 2
fi
```

#### Connection Verification

Use before executing critical operations to verify the daemon is available:

```php
// PHP example: Verify daemon before operations
$client = new LumoDaemonClient();
if ($client->ping()) {
    $client->execute('service.restart', ['service' => 'nginx']);
} else {
    throw new DaemonUnavailableException();
}
```

### Notes

- This command does not require audit logging due to its high-frequency health check nature
- Suitable for load balancer health checks and monitoring systems
- Minimal overhead as it performs no I/O operations beyond generating the response

---

## system.metrics

Metrics command that returns daemon health statistics. Provides comprehensive information about the daemon's operational status, including uptime, request counts, and connection information.

### Parameters

| Name | Type | Required | Description |
|------|------|----------|-------------|
| — | — | — | This command accepts no parameters |

### Response Format

| Field | Type | Description |
|-------|------|-------------|
| `uptime_seconds` | integer | How long the daemon has been running (in seconds) |
| `requests_total` | integer | Total number of requests processed since startup |
| `requests_failed` | integer | Number of failed requests since startup |
| `active_connections` | integer | Number of currently active connections |
| `nonce_store_size` | integer | Number of stored nonces for replay protection |
| `version` | string | Daemon version string (from Cargo.toml) |

### Example Request

```json
{
  "command": "system.metrics",
  "params": {}
}
```

### Example Response

```json
{
  "success": true,
  "data": {
    "uptime_seconds": 86400,
    "requests_total": 15234,
    "requests_failed": 42,
    "active_connections": 5,
    "nonce_store_size": 128,
    "version": "0.1.0"
  }
}
```

### Error Cases

This command has no specific error cases. It always succeeds if the daemon is running and able to process requests.

### Use Cases

#### Prometheus Metrics Endpoint

Expose daemon metrics for Prometheus scraping:

```python
# Example: Python exporter for Prometheus
from prometheus_client import Gauge, start_http_server
import json
import socket

uptime = Gauge('lumo_daemon_uptime_seconds', 'Daemon uptime in seconds')
requests_total = Gauge('lumo_daemon_requests_total', 'Total requests processed')
requests_failed = Gauge('lumo_daemon_requests_failed', 'Failed requests count')
active_connections = Gauge('lumo_daemon_active_connections', 'Current active connections')

def collect_metrics():
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect('/var/run/lumo/daemon.sock')
    sock.send(b'{"command":"system.metrics","params":{}}')
    response = json.loads(sock.recv(4096))

    data = response['data']
    uptime.set(data['uptime_seconds'])
    requests_total.set(data['requests_total'])
    requests_failed.set(data['requests_failed'])
    active_connections.set(data['active_connections'])
```

#### Dashboard Integration

Display daemon health statistics in admin dashboards:

```javascript
// Example: Fetch metrics for dashboard display
async function getDaemonMetrics() {
    const response = await daemonClient.execute('system.metrics', {});

    return {
        uptime: formatDuration(response.data.uptime_seconds),
        requestsTotal: response.data.requests_total,
        requestsFailed: response.data.requests_failed,
        successRate: calculateSuccessRate(
            response.data.requests_total,
            response.data.requests_failed
        ),
        activeConnections: response.data.active_connections,
        version: response.data.version
    };
}

function calculateSuccessRate(total, failed) {
    if (total === 0) return 100;
    return ((total - failed) / total * 100).toFixed(2);
}
```

#### Alerting and Thresholds

Set up alerts based on metrics thresholds:

```yaml
# Example: Alert configuration
alerts:
  - name: high_failure_rate
    condition: (requests_failed / requests_total) > 0.05
    message: "Daemon failure rate exceeds 5%"

  - name: connection_limit
    condition: active_connections > 100
    message: "Active connections approaching limit"

  - name: nonce_store_growth
    condition: nonce_store_size > 10000
    message: "Nonce store unusually large - possible attack"
```

#### Capacity Planning

Use historical metrics data for capacity planning:

```bash
# Collect metrics every minute for analysis
while true; do
    echo '{"command":"system.metrics","params":{}}' | \
        nc -U /var/run/lumo/daemon.sock | \
        jq -c '{ts: now, data: .data}' >> /var/log/lumo/metrics.jsonl
    sleep 60
done
```

### Notes

- This command does not require audit logging as it is a monitoring endpoint
- The `nonce_store_size` reflects the number of nonces stored for replay attack protection
- Use this endpoint for monitoring dashboards and alerting systems
- The success rate can be calculated as: `(requests_total - requests_failed) / requests_total`

---

## Common Characteristics

Both system commands share the following characteristics:

1. **No Required Parameters**: Neither command requires any input parameters
2. **No Audit Logging**: Both commands skip audit logging to reduce overhead for high-frequency monitoring use cases
3. **Always Succeed**: Under normal operation, these commands do not produce errors
4. **Lightweight**: Designed for minimal performance impact when called frequently
